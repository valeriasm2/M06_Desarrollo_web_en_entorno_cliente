<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>LOGRO 1 ‚Äì El Int√©rprete del Navegador</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.8; }
  h1 { color: #333; }
  h2 { color: #0056b3; margin-top: 30px; }
  pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
  hr { margin: 40px 0; }
</style>
</head>
<body>

<h1>LOGRO 1 ‚Äì El Int√©rprete del Navegador</h1>
<p><strong>Objetivo:</strong> Comprender c√≥mo se ejecuta JavaScript y su relaci√≥n con el DOM.</p>
<p><strong>Duraci√≥n:</strong> 10‚Äì12 minutos</p>

<hr>

<h2>Ejercicio 1: Orden de Carga (Concepto B√°sico)</h2>
<p><strong>Enunciado:</strong> Explica qu√© ocurre desde que el navegador carga una p√°gina hasta que JavaScript puede manipular el DOM.</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
1. El navegador descarga el archivo HTML.
2. Lo procesa l√≠nea por l√≠nea (parsing).
3. Construye el DOM (una representaci√≥n en memoria del HTML).
4. Cuando el DOM est√° completo, JavaScript ya puede manipularlo.
5. Si el &lt;script&gt; est√° al final del body, el DOM ya existe.
6. Si est√° arriba, se debe usar DOMContentLoaded para esperar.
</pre>

<hr>

<h2>Ejercicio 2: Esquema del Proceso</h2>
<p><strong>Enunciado:</strong> Dibuja un esquema simple del proceso HTML ‚Üí DOM ‚Üí JavaScript.</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
HTML (archivo f√≠sico en el servidor)
         ‚Üì descargado e interpretado
    DOM (estructura interna en memoria del navegador)
         ‚Üì manipulaci√≥n con JavaScript
JavaScript modifica el DOM
         ‚Üì
    La pantalla se actualiza (render)
</pre>

<hr>

<h2>Ejercicio 3: ¬øQu√© Modifica JavaScript?</h2>
<p><strong>Enunciado:</strong> ¬øJavaScript modifica el HTML original o solo el DOM?</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
Respuesta correcta: SOLO EL DOM.

El HTML original no cambia, solo la copia en memoria (DOM).

Ejemplo:
- Si inspeccionas el c√≥digo fuente (Ctrl+U), ver√°s el HTML original sin cambios.
- Si abres DevTools (F12), ver√°s el DOM modificado por JavaScript.
</pre>

<hr>

<h2>Ejercicio 4: Ubicaci√≥n de Scripts</h2>
<p><strong>Enunciado:</strong> ¬øPor qu√© es una buena pr√°ctica colocar los scripts al final del body?</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
Porque permite que el DOM exista antes de que JavaScript intente acceder a √©l.

Ventajas:
‚úÖ El HTML se carga primero
‚úÖ Los elementos existen en el DOM
‚úÖ JavaScript puede accederlos sin problemas
‚úÖ La p√°gina se ve m√°s r√°pida al usuario

Ejemplo CORRECTO:
&lt;body&gt;
  &lt;h1 id="titulo"&gt;Mi T√≠tulo&lt;/h1&gt;
  
  &lt;script&gt;
    document.getElementById("titulo").style.color = "red"; // ‚úÖ Funciona
  &lt;/script&gt;
&lt;/body&gt;
</pre>

<hr>

<h2>Ejercicio 5: Error Com√∫n</h2>
<p><strong>Enunciado:</strong> Describe un ejemplo donde JavaScript falle por ejecutarse antes de que exista un elemento.</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
C√ìDIGO INCORRECTO:
&lt;script&gt;
  document.getElementById("titulo").style.color = "red"; // ‚ùå ERROR
&lt;/script&gt;

&lt;h1 id="titulo"&gt;Mi T√≠tulo&lt;/h1&gt;

Error: document.getElementById("titulo") devuelve null porque el elemento a√∫n no existe.

SOLUCIONES:

Opci√≥n 1 - Mover script al final:
&lt;h1 id="titulo"&gt;Mi T√≠tulo&lt;/h1&gt;
&lt;script&gt;
  document.getElementById("titulo").style.color = "red"; // ‚úÖ Funciona
&lt;/script&gt;

Opci√≥n 2 - Usar DOMContentLoaded:
&lt;script&gt;
  document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("titulo").style.color = "red"; // ‚úÖ Funciona
  });
&lt;/script&gt;
&lt;h1 id="titulo"&gt;Mi T√≠tulo&lt;/h1&gt;

Opci√≥n 3 - Usar defer:
&lt;script defer&gt;
  document.getElementById("titulo").style.color = "red"; // ‚úÖ Funciona
&lt;/script&gt;
&lt;h1 id="titulo"&gt;Mi T√≠tulo&lt;/h1&gt;
</pre>

<hr>

<h2>Ejercicio 6: Orden de Ejecuci√≥n</h2>
<p><strong>Enunciado:</strong> Analiza el siguiente c√≥digo y escribe en orden qu√© aparecer√° en la consola.</p>

<p><strong>C√ìDIGO:</strong></p>
<pre>
console.log("1. Inicio");

document.addEventListener('DOMContentLoaded', function() {
  console.log("2. DOM listo");
});

console.log("3. Despu√©s del listener");

setTimeout(function() {
  console.log("4. Timeout 0ms");
}, 0);

console.log("5. Final del script");
</pre>

<p><strong>SOLUCI√ìN - Orden en consola:</strong></p>
<pre>
1. Inicio
3. Despu√©s del listener
5. Final del script
2. DOM listo
4. Timeout 0ms

EXPLICACI√ìN:
- Primero: c√≥digo sincr√≥nico (l√≠neas 1-5)
- Luego: eventos del DOM (DOMContentLoaded)
- Finalmente: tareas asincr√≥nicas (setTimeout)
</pre>

<hr>

<h2>Ejercicio 7: Eventos del Navegador</h2>
<p><strong>Enunciado:</strong> Crea un script que imprima en la consola cu√°ndo se cumplen estos eventos:
- Cuando comienza a cargar la p√°gina
- Cuando se descarga completamente el DOM
- Cuando se cargan todos los recursos
- Cuando el usuario intenta cerrar la p√°gina</p>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
console.log("Comienza la carga");

window.addEventListener('DOMContentLoaded', function() {
  console.log("DOM completamente cargado");
});

window.addEventListener('load', function() {
  console.log("Todos los recursos cargados (im√°genes, CSS, etc.)");
});

window.addEventListener('beforeunload', function() {
  console.log("El usuario intenta cerrar la p√°gina");
});

EVENTOS EXPLICADOS:
- DOMContentLoaded: Se dispara cuando el DOM est√° listo
- load: Se dispara cuando TODOS los recursos est√°n cargados (im√°genes, CSS, JS)
- beforeunload: Se dispara antes de abandonar la p√°gina
</pre>

<hr>

<h2>Ejercicio 8: Call Stack vs Event Loop</h2>
<p><strong>Enunciado:</strong> Predice el orden de salida en consola y explica por qu√©.</p>

<p><strong>C√ìDIGO:</strong></p>
<pre>
function prioridad1() {
  console.log("Funci√≥n 1");
}

console.log("Inicio");
setTimeout(prioridad1, 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("Fin");
</pre>

<p><strong>SOLUCI√ìN - Orden en consola:</strong></p>
<pre>
Inicio
Fin
Promise
Funci√≥n 1

EXPLICACI√ìN:
1. Se ejecuta c√≥digo sincr√≥nico: "Inicio" y "Fin"
2. Luego Promesas (microtareas) - tienen mayor prioridad
3. Finalmente setTimeout (macrotarea) - aunque est√© en 0ms

PRIORIDAD: Sincr√≥nico > Promesas > setTimeout
</pre>

<hr>

<h2>Ejercicio 9: Rendimiento - Reflow</h2>
<p><strong>Enunciado:</strong> ¬øCu√°l de estos dos c√≥digos es m√°s eficiente? Explica por qu√©.</p>

<p><strong>C√≥digo A (MENOS eficiente):</strong></p>
<pre>
for (let i = 0; i < 5; i++) {
  document.getElementById("caja").style.width = (100 + i * 10) + "px";
}
</pre>

<p><strong>C√≥digo B (M√ÅS eficiente):</strong></p>
<pre>
const caja = document.getElementById("caja");
for (let i = 0; i < 5; i++) {
  caja.style.width = (100 + i * 10) + "px";
}
</pre>

<p><strong>SOLUCI√ìN:</strong></p>
<pre>
B es m√°s eficiente porque:

- En A, se accede al DOM 5 veces con getElementById()
- En B, se accede una sola vez y se reutiliza la referencia
- El acceso al DOM es costoso en rendimiento
- B es aproximadamente 5 veces m√°s r√°pido

REGLA DE ORO: Guarda referencias a elementos del DOM en variables
para evitar acceder m√∫ltiples veces.
</pre>

<hr>

<h2>Ejercicio 10: Flujo Completo</h2>
<p><strong>Enunciado:</strong> Explica qu√© sucede en cada fase cuando se carga una p√°gina con un bot√≥n que tiene un event listener.</p>

<p><strong>HTML:</strong></p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script src="script.js" defer&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id="btn"&gt;Haz clic&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p><strong>JavaScript (script.js):</strong></p>
<pre>
console.log("1. Script cargado");

document.getElementById("btn").addEventListener("click", function() {
  console.log("3. Bot√≥n clickeado");
});

console.log("2. Event listener a√±adido");
</pre>

<p><strong>SOLUCI√ìN - Fases de ejecuci√≥n:</strong></p>
<pre>
FASE 1 - Parsing del HTML:
- El navegador lee el HTML
- Encuentra &lt;script defer&gt; ‚Üí descarga pero NO ejecuta

FASE 2 - DOM Ready:
- Se termina de parsear el HTML
- Se ejecuta el script (por defer)
- Salida en consola: "1. Script cargado" y "2. Event listener a√±adido"

FASE 3 - Interacci√≥n del usuario:
- Usuario hace clic en el bot√≥n
- Se ejecuta el callback del evento
- Salida en consola: "3. Bot√≥n clickeado"
</pre>

<hr>

<h2>üìå RESUMEN DE CONCEPTOS CLAVE</h2>
<pre>
HTML: Archivo de texto con etiquetas

DOM: Estructura en memoria que el navegador crea del HTML

Sincr√≥nico: Se ejecuta l√≠nea por l√≠nea, bloquea otras tareas

Asincr√≥nico: Se ejecuta despu√©s, sin bloquear (setTimeout, Promesas)

Event Loop: Verifica si hay tareas en la cola de ejecuci√≥n

DOMContentLoaded: Evento que se dispara cuando el DOM est√° listo

load: Evento que se dispara cuando TODO est√° cargado

Reflow: Recalcula posici√≥n y tama√±o de elementos

Repaint: Redibuja los elementos en pantalla

Call Stack: Pila de funciones en ejecuci√≥n

Microtareas: Promesas (alta prioridad)

Macrotareas: setTimeout, setInterval (baja prioridad)
</pre>

<hr>

<h2>‚úÖ TIPS IMPORTANTES</h2>
<pre>
1. Coloca &lt;script&gt; al final del &lt;body&gt; o usa 'defer'
2. Si necesitas manipular el DOM, espera con DOMContentLoaded
3. Guarda referencias a elementos DOM en variables
4. Accede al DOM lo menos posible para mejor rendimiento
5. Recuerda: JavaScript modifica el DOM, NO el HTML original
6. Prioridad de ejecuci√≥n: Sincr√≥nico > Promesas > setTimeout
7. Usa F12 para abrir la consola y ver mensajes de depuraci√≥n
</pre>

</body>
</html>
